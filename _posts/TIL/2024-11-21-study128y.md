---
title:  "[TIL] 128 [C#] 플로이드-워셜 알고리즘 (Floyd-Warshall) 최단경로"
excerpt: ""

categories:
    - Til
tags:
    - [C#, TIL]

toc: true
toc_sticky: true
 
date: 2024-11-21 09:00

---
- - -

`Tuple`

<center><H1>  공부 </H1></center>

&nbsp;&nbsp; 알고리즘 연습하기     
&nbsp;&nbsp; 클린코드 정리하기   
&nbsp;&nbsp; [ ] 디자인 코드 패턴 이해,정리하기. 책사기  
&nbsp;&nbsp; [ ] 자료구조 디자인패턴 강의 다시 듣기.   
&nbsp;&nbsp; 이분탐색, 그래프 문제 풀기  
&nbsp;&nbsp; 코테 greedy, string, data_structures, graphs, geometry 
{:style="border:1px solid #EAEAEA; border-radius: 7px;"}
{: .notice}  


<br><br><br><br>
- - - 

# 플로이드-워셜 알고리즘 (Floyd-Warshall)
모든 정점에서 **모든 정점으로의 최단 경로**를 구하는 알고리즘입니다.  
{:style="border:1px solid #EAEAEA; border-radius: 7px;"}
{: .notice}  

<br><br>

## 예시 

<div class="notice--primary" markdown="1"> 

```c# 

class Program
{
    static void Main()
    {
        var sw = new StreamWriter(Console.OpenStandardOutput());

        int users = 5;
        int[,] graph = new int[5,5];
        int INF = 1000000;

        
        // 1. 자기자신=0, 나머지 INF = 무한대(적당한크기)(Int,maxvalue는 X)
        for (int i = 1; i <= users; i++)
        {
            for (global::System.Int32 j = 1; j <= users; j++)
            {
                graph[i, j] =(i == j) ?  0 : INF;
            }
        }

        
        // 2. 무방향 그래프 간선 
        // 입력
        // 1 3
        // 1 4
        // 4 5
        // 4 3
        // 3 2
        for (int i = 0; i < con; i++)
        {
            int[] edge = Array.ConvertAll(Console.ReadLine().Split(' '), Convert.ToInt32);
            graph[edge[0], edge[1]] = 1;
            graph[edge[1], edge[0]] = 1;
        }
        

        // 3. 플로이드-워셜
        // j -> k 로 가는 최단거리 = j=>?=>k  경우의수의 최소값 
        for (int i = 1; i <= users; i++)
        {
            for (int j = 1; j <= users; j++)
            {
                for (int k = 1; k <= users; k++)
                {
                    graph[j,k]= Math.Min(graph[j, k], graph[j, i] + graph[i,k]);
                }
            }
        }

    }
}


```
</div>

<br><br>

### 1. 초기화
  
![1](https://github.com/user-attachments/assets/6f8ac7d5-8021-4848-96f6-3bf097ab86bb)  

<div class="notice--primary" markdown="1"> 

```c# 
// 1. 자기자신=0, 나머지 INF = 무한대(적당한크기)(Int,maxvalue는 X)
for (int i = 1; i <= users; i++)
{
    for (global::System.Int32 j = 1; j <= users; j++)
    {
        graph[i, j] =(i == j) ?  0 : INF;
    }
}

```
</div>

<br>

### 2. 간선 입력
  
![2](https://github.com/user-attachments/assets/08ef279f-1264-4be2-8c1c-82a773324760)  

<div class="notice--primary" markdown="1"> 

```c# 
// 2. 무방향 그래프 간선 
// 입력
// 1 3
// 1 4
// 4 5
// 4 3
// 3 2
for (int i = 0; i < con; i++)
{
    int[] edge = Array.ConvertAll(Console.ReadLine().Split(' '), Convert.ToInt32);
    graph[edge[0], edge[1]] = 1;
    graph[edge[1], edge[0]] = 1;
}

```
</div>

<br>

### 3. 플로이드 - 워셜  

x -> y 로의 최단 경로  
![3](https://github.com/user-attachments/assets/b8d9d60a-168f-4f41-909b-1efee106f544) 

<div class="notice--primary" markdown="1"> 

```c# 
// 3. 플로이드-워셜
// j -> k 로 가는 최단거리 = j=>?=>k  경우의수의 최소값 
for (int i = 1; i <= users; i++)
{
    for (int j = 1; j <= users; j++)
    {
        for (int k = 1; k <= users; k++)
        {
            graph[j,k]= Math.Min(graph[j, k], graph[j, i] + graph[i,k]);
        }
    }
}

```
</div>


<br><br><br>
- - - 


# 잡담, 일기?
튜플는 간단한 **두 개의 데이터 그룹을 다루는 데 매우 적합**합니다.  
더 복잡한 데이터 구조가 필요하면 **클래스나 구조체**를 사용하는 것도 좋은 방법입니다.
{:style="border:1px solid #EAEAEA; border-radius: 7px;"}
{: .notice--success}  


<br><br>
- - -